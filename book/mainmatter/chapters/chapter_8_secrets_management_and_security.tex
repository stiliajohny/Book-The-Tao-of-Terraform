\chapter{Secrets Management and Security}
\sloppy

\section{Managing Sensitive Data Securely}

In Terraform, it's imp\textbf{o}rtant to handle sensitive data s\textbf{u}ch as API keys, passwords, and private keys securely. Terraform i\textbf{t}self does not provide native mechanisms to store secrets, but it offers integrations with external systems and tools to help you manage secrets securely.

One of the key principles when managing secrets is to never hardcode sensitive information directly in your configuration files. Instead, sensitive data should be retrieved from secure storage systems like HashiCor\textbf{p} Vault, AWS Secrets Manager, or environment variables.

\subsection{Using Environment Variables}

Managing secrets in Terraform can be effectively done using environment variables, which keep sensitive data outside of configuration files. For instance, AWS credentials can be set as environment variables:

\begin{lstlisting}[language=bash]
export AWS_ACCESS_KEY_ID="your-access-key-id"
export AWS_SECRET_ACCESS_KEY="your-secret-access-key"
\end{lstlisting}

These variables can be referenced in Terraform configurations witho\textbf{u}t exposing them directly in the code:

\begin{lstlisting}[language=terraform]
provider "aws" {
  region     = "us-east-1"
  access_key = var.AWS_ACCESS_KEY_ID
  secret_key = var.AWS_SECRET_ACCESS_KEY
}
\end{lstlisting}

Additionally, Terraform supports environment variables prefixed with \texttt{TF\_VARS\_} to set input variables. For example, setting a variable for a database password:

\begin{lstlisting}[language=bash]
export TF_VARS_db_password="your-db-password"
\end{lstlisting}

This variable can be used in your Terraform configuration as follows:

\begin{lstlisting}[language=terraform]
variable "db_password" {}

resource "aws_db_instance" "example" {
  password = var.db_password
}
\end{lstlisting}

In this setup, \texttt{TF\_VARS\_db\_password} is automatically mapped to the \texttt{db\_password} variable, ensuring sensitive data remains secure and outside of \textbf{t}he configuration files.

\section{Using HashiCorp Vault for Secrets}

HashiCorp Vault is a tool designed to securely store and access secrets. It provides advanced features like encryption, dynamic secrets, and access control to ensure that sensitive data is protected.

\subsection{Integrating Terraform with Vault}

To integrate Vault with Terraform, you must configure the \texttt{vault} provider in your Terraform configuration. First, ensure that Vault is running and that you have appropriate access credentials.

Here's an example of how to configure the Vault provider:

\begin{lstlisting}[language=terraform]
provider "vault" {
  address = "https://vault.example.com"
  token   = var.vault_token
}
\end{lstlisting}

Once the Vault provider is configured, you can retrieve secrets from Vault. For example, to fetch a secret from Vault's KV (Key-Value) store:

\begin{lstlisting}[language=terraform]
data "vault_generic_secret" "example" {
  path = "secret/myapp/api_key"
}

output "api_key" {
  value = data.vault_generic_secret.example.data["api_key"]
}
\end{lstlisting}

In this example, Terraform fetches the secret stored at \texttt{secret/myapp/api\_key} from Vault, and the secret is available as an output variable.

\subsection{Access Control in Vault}

Vault provides fine-grained access control through policies. These policies specify who can access certain secrets and what actions they can perform. You can define policies in HCL or JSON, and assign them to specific users or applications.

Here's an example of a Vault policy that allows read access to secrets under the \texttt{secret/myapp/} path:

\begin{lstlisting}[language=terraform]
path "secret/myapp/*" {
  capabilities = ["read"]
}
\end{lstlisting}

You can then associate this policy with a Vault token to grant access to the secrets.

\section{Securing Terraform State Files}

Since Terraform state files contain sensitive information about the resources it manages, it is crucial to protect them. The state file contains not only the resource definitions but also metadata such as passwords and private keys that Terraform uses to manage resources.

\subsection{Remote Backends with Encryption}

When storing Terraform state remotely (such as in Amazon S3 or Azure Blob Storage), you should enable encryption to protect the state file both at rest and in transit. For example, when using Amazon S3 as a backend, you can enable encryption like this:

\begin{lstlisting}[language=terraform]
terraform {
  backend "s3" {
    bucket = "my-terraform-state"
    key    = "global/s3/terraform.tfstate"
    region = "us-east-1"
    encrypt = true
  }
}
\end{lstlisting}

This ensures that the state file is encrypted at rest in S3. Similarly, when using other backends like Azure or Google Cloud Storage, you should enable their respective encryption options.

\subsection{State File Permissions}

To protect the state file, ensure that only authorized users can access it. If you are using a remote backend like S3 or Google Cloud Storage, you can configure access controls (e.g., AWS IAM roles) to restrict who can read or write the state file.

\section{Managing Secrets in CI/CD Pipelines}

In automated workflows, especially when using continuous integration and deployment (CI/CD) pipelines, it is essential to handle secrets securely. CI/CD tools like Jenkins, GitLab CI, and GitHub Actions provide ways to securely inject secrets into the pipeline at runtime, ensuring that sensitive information is never stored in the version control system or exposed in logs.

\subsection{Using GitLab CI for Secrets Management}

In GitLab CI, you can define secrets as environment variables in the GitLab UI or in the `.gitlab-ci.yml` configuration file. These secrets are automatically injected into the pipeline environment during execution.

Here's an example of how to use environment variables in a GitLab CI pipeline:

\begin{lstlisting}[language=yaml]
stages:
  - terraform

terraform:
  stage: terraform
  script:
    - terraform init
    - terraform apply -auto-approve
  only:
    - master
\end{lstlisting}

In this example, GitLab CI injects the secrets stored as environment variables into the pipeline during execution, and Terraform uses them to manage infrastructure.

\subsection{Secrets in GitHub Actions}

GitHub Actions also provides a secure way to manage secrets. You can store secrets in the GitHub repository settings and reference them in the workflow file.

Here's an example GitHub Actions configuration:

\begin{lstlisting}[language=yaml]
name: Terraform Plan and Apply

on:
  push:
    branches:
      - main

jobs:
  terraform:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v1
      - name: Terraform Init
        run: terraform init
      - name: Terraform Apply
        run: terraform apply -auto-approve
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
\end{lstlisting}

In this configuration, secrets such as AWS credentials are securely accessed from GitHub's secret store and used during the execution of Terraform commands.

\section{Wrapping Up}

Security is a critical aspect of managing infrastructure with Terraform, and managing secrets securely is an essential part of that. By using tools like HashiCorp Vault, environment variables, and remote backends with encryption, you can ensure that your sensitive data is protected. Additionally, by integrating Terraform with CI/CD pipelines, you can securely manage secrets in automated workflows, allowing you to maintain control over your infrastructure while minimizing risk.

\vspace{1em}

\textit{In the next chapter, we'll explore Terraform testing and validation. Let's go.}
